# transfer-dapp 再調査レポート（ハードコード削除後）

## 調査日時
2025-08-03

## 修正内容
`api/ada/requests/[id].js`から緊急テストコード（ハードコード）を削除し、実際のデータ取得ロジックを有効化しました。

## 修正後の動作フロー

### データ取得ロジック（修正後）
```javascript
// 1. リクエスト一覧APIを呼び出す
const baseUrl = req.headers.origin || 'http://localhost:4000';
const listResponse = await fetch(`${baseUrl}/api/ada/requests`);

// 2. リクエスト一覧から指定IDのものを検索
const listData = await listResponse.json();
const requestData = listData.requests?.find(req => req.id === id);

// 3. 見つかった場合はデータを返す、見つからない場合は404
```

## 新たに発見された問題

### 1. インメモリキャッシュの共有問題
- `api/ada/requests.js`と`api/ada/requests/[id].js`は別々のサーバーレス関数
- Vercel環境では、各関数が独立したプロセスで実行される可能性がある
- そのため、`requests.js`で作成したデータが`[id].js`から直接アクセスできない

### 2. 現在の回避策の効率問題
- 個別のリクエストを取得するために、毎回全リクエストを取得している
- リクエスト数が増えると、パフォーマンスが悪化する
- ネットワークの往復が発生し、レスポンスが遅くなる

### 3. データの永続性問題
- インメモリキャッシュは関数の再起動で失われる
- Vercelのサーバーレス関数は一定時間後に自動的にシャットダウンされる
- そのため、作成したリクエストが突然消える可能性がある

## 現在の実装の動作確認

修正後の実装は以下のように動作します：

1. **リクエスト作成時**（`POST /api/ada/requests`）
   - リクエストデータをインメモリキャッシュに保存
   - 署名URLを返す

2. **個別リクエスト取得時**（`GET /api/ada/requests/:id`）
   - リクエスト一覧API（`GET /api/ada/requests`）を内部的に呼び出す
   - 取得した一覧からIDで検索
   - 該当するリクエストを返す

3. **問題のシナリオ**
   - ユーザーAがリクエストを作成（関数インスタンスA）
   - ユーザーBが署名URLにアクセス（関数インスタンスB）
   - インスタンスBから一覧APIを呼び出す（関数インスタンスC）
   - インスタンスCがインスタンスAと異なる場合、データが見つからない

## 推奨される解決策

### 短期的な解決策
1. **Redis等の外部キャッシュサービスの利用**
   - Vercel KVやUpstash Redisなどのサービスを利用
   - 関数間でデータを共有可能

2. **データベースの利用**
   - PostgreSQLやMongoDBなどの永続的なストレージ
   - すでにプロジェクトにはPostgreSQLの設定がある

### 長期的な解決策
1. **専用のバックエンドサーバーの構築**
   - Express/Fastifyなどで独立したAPIサーバー
   - WebSocketサポート（すでにSocket.ioの設定あり）

2. **マイクロサービスアーキテクチャ**
   - リクエスト管理サービス
   - トランザクション処理サービス
   - 認証サービス

## 現在の動作状況
- ハードコードは削除されたが、データ共有の問題により正常に動作しない可能性が高い
- 同じサーバーレス関数インスタンスにヒットした場合のみ動作する（運に依存）
- 開発環境では動作する可能性があるが、本番環境では問題が顕在化する

## 次のステップ
1. 外部データストアの導入（Redis推奨）
2. 既存のPostgreSQLデータベースの活用検討
3. エラーハンドリングの改善
4. ログ機能の強化